"""
______________________________________________________________________________________
직렬화 방법은 크게 세 가지가 존재한다. 
1. 관련된 객체의 pk만 있으면 되는지 > ForeignKey를 사용하고, 추가적인 필드 지정을 하지 않는다. 이후 필드에 {참조하려는 모델 이름}_set을 추가한다.
2. 문자열이 필요한지 > 1번에서 수행한 것들을 동일하게 수행하고, __str__ 메소드 지정, S{참조하려는 모델 이름}_set에 tringRelatedField 값을 저장한다.
3. 객체의 모든 정보가 필요한지 (Serializer에서 필드 이름과 동일한 이름의 변수에 nested serializer를 저장)
______________________________________________________________________________________
"""

"""
______________________________________________________________________________________
ForeignKey는 Django에서 모델 간의 1:N(일대다) 관계를 정의할 때 사용하는 필드이다.
관계형 데이터베이스에서 다른 테이블의 기본키(primary key)를 참조하여 연결 관계를 맺는 역할을 한다.

movie = models.ForeignKey(Movie, on_delete=models.CASCADE)

해당 코드는 다음을 나타낸다.
1. Review 모델은 Movie 모델과 연결되어 있다. 이때 Review가 Movie를 '참조한다' 라고 칭한다.
2. 하나의 Movie는 여러개의 Review를 가질 수 있다.
3. Review의 데이터에서 Movie의 id를 열람할 수 있다.ㅌ

인자:
    첫번째 인자(Movie) : 어떤 모델을 참조할지 지정
    두번째 인자(on_delete): 참조된 객체가 삭제될 때의 행동을 정의. 주된 행동들은 다음과 같음:
        models.CASCADE: 참조된 객체가 삭제되면 함께 삭제됨
        models.SET_NULL: 참조된 객체가 삭제되면 null로 설정 (이 경우 null=True도 설정해야 함)
        models.PROTECT: 참조된 객체가 삭제되지 않도록 막음
        models.DO_NOTHING: 아무것도 하지 않음 (주의 필요)
______________________________________________________________________________________
"""

"""
______________________________________________________________________________________
model파일을 사용해 데이터베이스를 수정하는 명령어들:
______________________________________________________________________________________
| 명령어              | 역할                   | 대상                  | 비고                    |
| ---------------- | -------------------- | ------------------- | -------------------       |
| `makemigrations` | 모델 변경 → 마그 파일 생성 | `models.py`         | 실제 DB는 안 건드림           |
| `migrate`        | 마그 파일 → DB 반영     | DB                   | 실제 테이블 생성/변경 등 적용    |
| `loaddata`       | JSON 등 초기 데이터 삽입 | `.json`, `.yaml` 파일 | 더미 데이터나 초기값 채우기에 사용 |
______________________________________________________________________________________
"""

"""
Model 분리 기준:
✅ 1. 반복성 (Reusability / 재사용 가능성)
동일한 정보가 여러 곳에서 참조될 가능성이 있는가?

예: 여러 유저가 동일한 인공지능 캐릭터(Rin, Min 등)를 사용할 수 있음 → Character는 분리해야 함.

반례: 사용자의 생년월일 → 오직 하나의 유저에만 해당됨 → User에 직접 넣는 게 적절.

✅ 2. 확장성 (Scalability)
해당 데이터 구조가 앞으로 커질 가능성이 있는가?

예: 캐릭터마다 다양한 컨텐츠가 생기고, 이름, 성격, 기능, 일종의 로그 기록까지 필요할 수 있음 → 독립 모델 필요.

반례: 사용자의 MBTI 하나만 저장 → User 모델 안에 필드로 넣는 게 간단함.

✅ 3. 변경 주기 / 독립성 (Update frequency & autonomy)
해당 데이터는 독립적으로 CRUD가 필요한가?

예: 캐릭터 정보(설명, 분석 알고리즘 등)는 유저와 관계없이 따로 수정될 수 있음.

반례: 유저의 알림 시간 설정은 유저 정보 변경의 일부임 → User 안에 저장.

✅ 4. 관계 구조의 명확성 (Relationship clarity)
1:N, M:N 관계가 명확하게 보이는가?

예: 하나의 캐릭터는 여러 유저에게 연결될 수 있음 (1:N)

예: 유저가 여러 캐릭터와 상호작용할 수 있고, 캐릭터도 여러 유저와 연결됨 (M:N) → 중간 테이블(UserCharacterInteraction) 필요

✅ 5. 논리적 독립성 (Conceptual separation)
해당 개체가 독립적인 "존재"로서 의미가 있는가?

예: Character는 명확한 역할과 속성을 가진 독립 개체임 (이름, 성격, 기능 등)

반례: 유저가 선택한 '활동 시간대'는 단순 속성임.
______________________________________________________________________________________
| 기준      | 적용 예시               | 분리 여부 |
| ------- | ------------------- | ----- |
| 반복성     | 여러 유저가 하나의 캐릭터 사용   | ✅ 분리  |
| 확장성     | 캐릭터에 다양한 기능/필드 생김   | ✅ 분리  |
| 독립 변경   | 캐릭터 정보만 따로 관리 가능    | ✅ 분리  |
| 관계 구조   | 유저\:M 캐릭터 → M\:N 구조 | ✅ 분리  |
| 논리적 독립성 | 캐릭터는 독립된 개념         | ✅ 분리  |
______________________________________________________________________________________
"""